#!/usr/bin/env python
#-----------------------------------------------------------------------
# main.py
# Author: Ethan Seide, Arin Champati, Chaz Bethel-Brescia
#-----------------------------------------------------------------------

from flask import Flask, request, make_response, redirect, url_for
from flask import render_template, session, flash
from Database.database import Database, Users
from course_graph import CourseGraph
from cas_client import CASClient
from main_util import authenticate, handleError, validate_inputs
import sys
import traceback
from DataSources.DataFiles.AreasOfStudy import CODE_TO_MAJOR, MAJOR_TO_CODE, CERTIFICATE_TO_CODE
from DataSources.user_info import UserInfo
from Database.session_maker import Session
from json import dumps
import re
import urllib
#-----------------------------------------------------------------------

app = Flask(__name__)
database = Database()
# Generated by os.urandom(16)
app.secret_key = b'k\x11\x8f\xe2\xa0\xda\x83\xfc-_\x93*\x0b\x12\xaa-'
MAX_SUGGESTIONS = 10
MAX_COURSES = 50 # how many non-suggested courses to show when filtering
MIN_PREFERENCE = 2
MAX_PREFERENCE = 6
MAX_DROPDOWN = 30
MAX_EDGES_SHOWN = 5 # how many edges to show on the information page

#-----------------------------------------------------------------------

# HOME PAGE
@app.route('/', methods=['GET'])
@app.route('/index', methods=['GET'])
@app.route('/home', methods=['GET'])
def index():
    if not session.get('logged_in'):
        session['logged_in'] = False
        
    html = render_template('home.html', session=session)
    return make_response(html)

#-----------------------------------------------------------------------

# FAQ PAGE
@app.route('/faq', methods=['GET'])
def faq():
    if not session.get('logged_in'):
        session['logged_in'] = False
        
    html = render_template('faq.html', session=session)
    return make_response(html)

# LOGIN PAGE
@app.route('/login', methods=['GET', 'POST'])
def login():
    authenticate()
    return redirect(url_for('dashboard'))


@app.route('/logout', methods=['GET'])
def logout():
    session['logged_in'] = False
    session.pop('logged_in', None)

    casClient = CASClient()
    casClient.authenticate()
    casClient.logout()
    return redirect(url_for('index'))

# -------------------------------------------------------------------

def __validate_course_list(course_list):
    """
    Given a course list, returns true if 
    we have a sufficient number of courses
    and false if otherwise
    """
    if course_list == None:
        return False

    filled_courses_count = 0
    for courseid in course_list:
        if not courseid or courseid=='':
            continue
        else:
            filled_courses_count+=1
    
    if filled_courses_count >= MIN_PREFERENCE:
        return True
    else:
        return False

# DASHBOARD PAGE
@app.route('/dashboard', methods=['GET'])
def dashboard():
    netid = authenticate()


    # Initializes and constructs new CourseGraph
    try:
        sess = Session()
        graph = CourseGraph(database, sess, MAX_SUGGESTIONS, MAX_COURSES)

    except Exception as e:
        return handleError(e, verbose="Error building graph", session=sess)
    finally:
        sess.close()

    # get the user information
    try:
        sess = Session()
        resp = database.get_user_info(sess, netid)
        name, year, major, email = resp.values()
        major = CODE_TO_MAJOR.get(major)

        # If the user does not exist in the database, send them to the user page
        # or if somehow there is information missing
        if not name or name=='':
            flash('Please complete your profile')
            return redirect(url_for('profile'))

        if not year or year=='':
            flash('Please complete your profile')
            return redirect(url_for('profile'))

        if not major or major=='':
            flash('Please complete your profile')
            return redirect(url_for('profile'))
        
        # if not email or email=='':
        #     flash('Please complete your profile')
        #     return redirect(url_for('profile'))

        # get all user class info
        favorite = database.get_fav_fifth(sess, netid)
        if not favorite or favorite=='':
            flash('Please complete your profile')
            return redirect(url_for('profile')) 

        liked = database.get_liked(sess, netid)
        validate_liked = __validate_course_list(liked)
        if validate_liked == False:
            flash('Please complete your profile')
            return redirect(url_for('profile')) 

        disliked = database.get_disliked(sess, netid)
        validate_disliked = __validate_course_list(disliked)
        if validate_disliked == False:
            flash('Please complete your profile')
            return redirect(url_for('profile')) 

    except Exception as e:
        return handleError(e, verbose="Error getting user information.", session=sess)
    finally:
        sess.close()

    # get the user suggestions
    try:
        sess = Session()
        suggestions = graph.cacheUserSuggestions(database, sess, netid)  ###########

        sess.commit()
        sess.close()

    except Exception as e:
        return handleError(e, verbose="Error getting user suggestions.", session=sess)
    finally:
        sess.close()
    
    # render the dashboard page
    html = render_template('dashboard.html',  max_courses=MAX_COURSES, max_suggestions=MAX_SUGGESTIONS)
    
    return make_response(html) 

# -------------------------------------------------------------------

# PROFILE PAGE
@app.route('/profile', methods=['GET','POST'])
def profile():
    netid = authenticate()
    
    # if the request method was post, then we have to
    # make changes in the database with the updated user info
    if request.method == 'POST':
        # Get personal info
        name = request.form.get('name')
        year = request.form.get('year')
        major = request.form.get('major')

        if  MAJOR_TO_CODE.get(major):
            major = MAJOR_TO_CODE.get(major)[0]
        if not major:
            major = ''
        # email = request.form.get('email')
        info = UserInfo.getInfo(netid) 
        email = info.get('email').lower()

        # Favorite course
        try:
            favorite = request.form.get('favorite')
            if favorite is not None:
                favorite = favorite.split(' / ')[0]
                sess = Session()
                favCourseId = database.get_courseid_from_deptnum(sess, favorite)
            
        except Exception as e:
            return handleError(e, "Error updating favorite course.", session=sess)     
        finally:
            sess.close()
        
        # Certificates
        try:
            sess = Session()
            certificates = []      
            for i in range(1, MAX_SUGGESTIONS + 1):
                cert = request.form.get('certificate' + str(i))
                if cert is not None and cert!= '':
                    certid = CERTIFICATE_TO_CODE.get(cert)
                    certificates.append(certid)
            

        except Exception as e:
            return handleError(e, "Error updating certificates.", session=sess)
        finally:
            sess.close()

        # Liked courses
        try:
            sess = Session()
            liked = []
            for i in range(1, MAX_PREFERENCE + 1):
                deptNum = request.form.get('liked' + str(i))
                if deptNum is not None and deptNum!= '':
                    deptNum = deptNum.split(' / ')[0]
                    courseid = database.get_courseid_from_deptnum(sess, deptNum)
                    liked.append(courseid)

        except Exception as e:
            return handleError(e, "Error updating liked course.", session=sess)       
        finally:
            sess.close()
        
        # Disliked courses and suggestions
        try:
            sess = Session()
            disliked = []      
            for i in range(1, MAX_PREFERENCE + 1):
                deptNum = request.form.get('disliked' + str(i))
                if deptNum is not None and deptNum!= '':
                    deptNum = deptNum.split(' / ')[0]
                    courseid = database.get_courseid_from_deptnum(sess, deptNum)
                    disliked.append(courseid)
            
            disliked_suggestions = []    
            for i in range(1, MAX_PREFERENCE + 1):
                deptNum = request.form.get('disliked-suggestion' + str(i))
                if deptNum is not None and deptNum!= '':
                    deptNum = deptNum.split(' / ')[0]
                    courseid = database.get_courseid_from_deptnum(sess, deptNum)
                    disliked_suggestions.append(courseid)
                        
        except Exception as e:
            return handleError(e, "Error updating disliked course/suggestions.", session=sess)
        finally:
            sess.close()
        
        try:
            # CHECKING IF THE FIELDS ENTERED ARE VALID

            liked_valid, disliked_valid, fav_valid, cert_valid, major_valid, year_valid = validate_inputs(liked, disliked, disliked_suggestions, favCourseId, certificates, major, year)

            sess = Session()

            # Get the user info in case we need to commit with the previous version due to an error
            resp = database.get_user_info(sess, netid)
            _, year_replace, major_replace, _ = resp.values()

            # commit the user info with the valid information
            if not year_valid and major_valid:
                database.update_user_info(sess, netid, name, year_replace, major, email)
            elif year_valid and not major_valid:
                database.update_user_info(sess, netid, name, year, major_replace, email)
            else:
                database.update_user_info(sess, netid, name, year, major, email)

            if cert_valid:
                database.update_user_certificates(sess, netid, certificates)
            
            if not liked_valid:
                liked = None

            if not disliked_valid:
                disliked = None
            
            if not fav_valid:
                favorite = None
            else:
                # need to make favorite a list when we pass it through
                favorite = [favCourseId]
            

            database.update_edges(sess, netid, favorite, liked, disliked)
            database.update_disliked_suggestions(sess, netid, disliked_suggestions)
            sess.commit()
            
        except Exception as e:
            return handleError(e, "Error updating user info.", session=sess)
        finally:
            sess.close()

        return redirect(url_for('profile'))

    # if no post request was made, we need to populate the form and display it
    else:
        # get the user information
        try:            
            sess = Session()
            resp = database.get_user_info(sess, netid)
            name, year, major, email = resp.values()
            major = CODE_TO_MAJOR.get(major)
            certificates = database.get_certificates(sess, netid)    

            if not certificates:
                certificates = []
            
            # If we have some missing fields, prepopulate the profile page with 
            # the user info from the datasource
            info = UserInfo.getInfo(netid) 
            if not major:
                major = ''
            if not name:
                name = info.get('name')
            if not email:
                email = info.get('email').lower()

        except Exception as e:
            return handleError(e, "Error getting user information.", session=sess)     
        finally:
            sess.close()
        
         # get user fav class info
        try:
            sess = Session()

            favorite = database.get_fav_fifth(sess, netid)
        
        except Exception as e:
            return handleError(e, "Error getting favorite course.", session=sess)  
        finally:
            sess.close()
        
        # get user liked class info
        try:
            sess = Session()

            liked = database.get_liked(sess, netid)
            # if there are no liked courses for the user, populate the list with
            # empty cells
            if not liked:
                liked = []
                for _ in range(MIN_PREFERENCE):
                    liked.append('')
            # if there are insufficient liked courses for the user, fill the rest with empty cells
            else:
                length = len(liked)
                if length < MIN_PREFERENCE:
                    diff = MIN_PREFERENCE - length
                    for _ in range(diff):
                        liked.append('')
        
        except Exception as e:
            return handleError(e, "Error getting liked courses.", session=sess) 
        finally:
            sess.close()

        # get user disliked class info
        try:
            sess = Session()

            disliked = database.get_disliked(sess, netid)

            # if there are no disliked courses for the user, populate the list with
            # empty cells
            if not disliked:
                disliked = []
                for _ in range(MIN_PREFERENCE):
                    disliked.append('')

            # if there are insufficient liked courses for the user, fill the rest with empty cells
            else:
                length = len(disliked)
                if length < MIN_PREFERENCE:
                    diff = MIN_PREFERENCE - length
                    for _ in range(diff):
                        disliked.append('')

        except Exception as e:
            return handleError(e, "Error getting disliked courses.", session=sess)
        finally:
            sess.close()
        
        try:
            sess = Session()
            # get user disliked suggestion info
            disliked_suggestions = database.get_disliked_suggestions(sess, netid)

        except Exception as e:
            return handleError(e, "Error getting disliked suggestions.", session=sess) 
        finally:
            sess.close()
                
    # render the profile page
    html = render_template('profile.html', netid=netid, name=name, year=year, major=major, \
        email=email, favorite=favorite, liked=liked, disliked=disliked, certificates=certificates, \
        disliked_suggestions=disliked_suggestions, min_preference=MIN_PREFERENCE, max_preference=MAX_PREFERENCE, session=session)

    return make_response(html) 

# -------------------------------------------------------------------
# APIs for AJAX Retrievals
# -------------------------------------------------------------------
@app.route('/suggestions', methods=['GET'])
def suggestions():
    netid = authenticate()

    try:
        sess = Session()

        suggestion_ids = database.get_suggestions(sess, netid)
        sess.commit()

        suggestions = []
        for courseid in suggestion_ids:
            crosslistings = database.get_crosslistings(sess, courseid)
            crossStr = ' / '.join(crosslistings)
            suggestions.append(crossStr)
        
        jsonStr = dumps(suggestions[:MAX_SUGGESTIONS])
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json'
        return response
    
    except Exception as e:
        return handleError(e, verbose="Error generating suggestions", session=sess, isJson=True)
    finally:
        sess.close()

@app.route('/refresh', methods=['GET'])
def refresh():
    netid = authenticate()

    # error handling (not quite done yet)
    errorMsg = request.args.get('errorMsg')

    disliked_sugg_deptnum = request.args.get('disliked_sugg')
    disliked_sugg_deptnum = urllib.parse.unquote(disliked_sugg_deptnum)
    try:
        sess = Session()

        # get id of disliked suggestion
        disliked_sugg_deptnum = disliked_sugg_deptnum.split(' / ')[0]  # parse only one crosslisting
        disliked_sugg_id = database.get_courseid_from_deptnum(sess, disliked_sugg_deptnum)

        # refresh suggestions
        refreshed_sugg_ids = database.refresh_suggestions(sess, netid, disliked_sugg_id)
        sess.commit()

        crosslistings = ''
        # formulate response with refreshed suggestions
        if (len(refreshed_sugg_ids) >= MAX_SUGGESTIONS):
            new_sugg_id = refreshed_sugg_ids[MAX_SUGGESTIONS - 1]
            if new_sugg_id != '' and new_sugg_id is not None:
                crosslistings = database.get_crosslistings(sess, new_sugg_id)
                crosslistings = ' / '.join(crosslistings)
        
        jsonStr = dumps(crosslistings)
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json'
        return response
    
    except Exception as e:
        return handleError(e, verbose="Error refreshing suggestions", session=sess, isJson=True)
    finally:
        sess.close()

# -------------------------------------------------------------------

def __requestArgs(args):
    results = []
    for arg in args:
        req = request.args.get(arg)
        if req is None:
            req = ''
        results.append(req)
    return results

# -------------------------------------------------------------------

def __natural_sort(l): 
    convert = lambda text: int(text) if text.isdigit() else text.lower() 
    alphanum_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ] 
    return sorted(l, key = alphanum_key)

@app.route('/courses', methods=['GET'])
def courses():
    authenticate()

    deptNum = request.args.get('deptNum')
    if deptNum is None:
        deptNum = ""

    try:
        sess = Session()

        if deptNum == "":
            deptNums = []
        else:
            deptNums = database.get_list_of_deptnum(sess, deptNum)

        deptNums = __natural_sort(deptNums[:MAX_DROPDOWN])
        jsonStr = dumps({'input': deptNum, 'values': deptNums})
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json'
        return response

    except Exception as e:
        return handleError(e, verbose="Error getting list of deptNums", session=sess, isJson=True)
    finally:
        sess.close()  

@app.route('/majors', methods=['GET'])
def majors():
    authenticate()

    maj = request.args.get('major')

    if maj is None:
        maj = ""

    try:
        majs = database.get_maj_list(maj)
        jsonStr = dumps({'input': maj, 'values': majs})
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json'
        return response
    except Exception as e:
        return handleError(e, verbose="Error getting list of majors", isJson=True)

@app.route('/certificates', methods=['GET'])
def certificates():
    authenticate()
    
    cert = request.args.get('certificate')

    if cert is None:
        cert = ""

    try:
        certs = database.get_cert_list(cert)
        jsonStr = dumps({'input': cert, 'values': certs})
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json'
        return response
    except Exception as e:
        return handleError(e, verbose="Error getting list of certificates", isJson=True)

@app.route('/filters', methods=['GET'])
def filters():
    netid = authenticate()

    filter = request.args.get('type')
    sess = Session()

    try:
        graph = CourseGraph(database, sess, MAX_SUGGESTIONS, MAX_COURSES)
        if filter == 'mostliked':
            filterResponse = graph.getMostLiked(database, sess, netid)
        elif filter == 'mostdisliked':
            filterResponse = graph.getMostDisliked(database, sess, netid)
        elif filter == 'favorites':
            filterResponse = graph.getFavorites(database, sess, netid)
        else:
            # If no filter, return default suggestions
            return make_response("")
                        
        jsonStr = dumps({"Status": "Success", "filter": filter, "courses": filterResponse})
        response = make_response(jsonStr)
        response.headers['Content-Type'] = 'application/json' 
        return response
    except Exception as e:
        return handleError(e, verbose="Error with filters", session=sess, isJson=True)
    finally:
        sess.close()
    
@app.route('/course-info', methods=['GET'])
def information():
    netid = authenticate()

    deptnum = request.args.get('deptNum')
    if not(deptnum is None or deptnum == ''):
          
        full_deptnum = {'deptnum': deptnum}
        deptnum = deptnum.split()[0] + ' ' + deptnum.split()[1] 
        
        try:
            sess = Session()

            courseid = database.get_courseid_from_deptnum(sess, deptnum)
            course_info = database.get_all_course_info(sess, courseid)
            score = database.get_course_score(sess, netid, courseid)
            edges_from = database.get_top_edges_from(sess, courseid, MAX_EDGES_SHOWN)
            course_info['course_numbers'].update(score)
            course_info['course_details'].update(full_deptnum)
            course_info['course_edges'] = edges_from
        
            jsonStr = dumps(course_info)

        except Exception as e:
            return handleError(e, verbose="Error getting course info", session=sess, isJson=True)
        finally:
            sess.close()
    else:
        jsonStr = dumps(None)
    
    response = make_response(jsonStr)
    response.headers['Content-Type'] = 'application/json'
    return response

# ----------------------------------------------------------------

if __name__ == '__main__':
    app.run('localhost', port=55555, debug=True)